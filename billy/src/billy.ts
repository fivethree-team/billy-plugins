import { App, Command } from "@fivethree/billy-core";
import { MarkdownTableHeader } from "@fivethree/billy-plugin-markdown";
import { BillyMethodDocumentation } from "@fivethree/billy-plugin-docs";
import { Plugins } from "./plugins";

export const plugins: Plugin[] = [{
    name: 'Markdown',
    path: '../markdown',
    docPath: './markdown'
}, {
    name: 'Billy Docs',
    path: '../billy-docs',
    docPath: './billy-docs'
}, {
    name: 'docx',
    path: '../docx',
    docPath: './docx'
}, {
    name: 'Google',
    path: '../google',
    docPath: './google'
}, {
    name: 'ngrok',
    path: '../ngrok',
    docPath: './ngrok'
}, {
    name: 'notify',
    path: '../notify',
    docPath: './notify'
}, {
    name: 'Telegram',
    path: '../telegram',
    docPath: './telegram'
}, {
    name: 'toggl',
    path: '../toggl',
    docPath: './toggl'
}, {
    name: 'twitter',
    path: '../twitter',
    docPath: './twitter'
}]

@App({ allowUnknownOptions: true })
export class Billy extends Plugins {

    @Command('Generate Readme ðŸ‘¾')
    async readme() {

        const headers: MarkdownTableHeader[] = [
            {
                key: 'name',
                title: 'Plugin'
            },
            {
                key: 'docPath',
                title: 'Documentation'
            },
        ];

        const mappedPlugins = plugins.map(plugin => {
            plugin.docPath = this.mdUrl(plugin.docPath, 'Readme');
            return plugin;
        });

        const pluginContent = this.createMdBuilder({ hasAutoGeneratedComment: true })
            .lineBreak()
            .h1('Plugins', true)
            .table(headers, mappedPlugins)
            .build();

        const docs = await this.billyDocs('.');

        const laneDocs = this.getLanesMarkdown(docs.methods);

        const appDocs = this.createMdBuilder({ hasAutoGeneratedComment: true })
            .lineBreak()
            .h1(docs.name, true)
            .h5(docs.description, true)
            .comment(laneDocs)
            .build();


        let readmeContent = this.readText('../README.md');

        const autoGeneratedContentIndex = readmeContent.indexOf(this.mdComment('Auto Generated Below'));
        if (autoGeneratedContentIndex > -1) {
            readmeContent = readmeContent.substring(0, autoGeneratedContentIndex);
        }

        this.writeText('../README.md', readmeContent + pluginContent);
    }

    @Command('Generate Plugins Readme ðŸ‘¾')
    async docs() {
        await this.documentPlugins(...plugins);
    }

    @Command('Publish @fivethree/billy-plugin-markdown')
    async publishMarkdownPlugin() {
        await this.updatePluginVersion('../markdown');
        await this.publishPlugin('../markdown');
    }

    private async publishPlugin(path: string) {
        await this.exec(`cd ${path} && npm run build && npm publish --access=public`, true);
    }

    private async updatePluginVersion(path: string) {
        const answer = await this.prompt([
            {
                type: 'list',
                name: 'update',
                message: 'Which version do you want to update the Markdown Plugin too?',
                choices: [
                    { name: 'Patch', value: 0 },
                    { name: 'Minor', value: 1 },
                ]
            }
        ]);

        switch (answer.update) {
            case 0:
                await this.exec(`cd ${path} && npm version patch`, true);
                break;
            case 1:
                await this.exec(`cd ${path} && npm version minor`, true);
                break;
        }
    }

    @Command('Build plugins')
    async build() {
        await this.buildPlugins(...plugins);
    }

    @Command('Clean install plugins')
    async clean() {
        await this.cleanPlugins(...plugins);
    }

    @Command('Publish all plugins')
    async publish() {
        await this.publishPlugins(...plugins);
    }

    async buildPlugins(...plugins: Plugin[]) {
        if (plugins && plugins.length > 0) {
            await processAsyncArray(plugins, async (plugin: Plugin) => {
                await this.exec(`cd ${plugin.path} && npm run build`, true)
            })
        }
    }

    async cleanPlugins(...plugins: Plugin[]) {
        if (plugins && plugins.length > 0) {
            await processAsyncArray(plugins, async (plugin: Plugin) => {
                await this.exec(`cd ${plugin.path} && npm run refresh`, true)
            })
        }
    }
    async publishPlugins(...plugins: Plugin[]) {
        if (plugins && plugins.length > 0) {
            await processAsyncArray(plugins, async (plugin: Plugin) => {
                await this.updatePluginVersion(plugin.path);
                await this.publishPlugin(plugin.path);
            })
        }
    }

    async documentPlugins(...plugins: Plugin[]) {
        if (plugins && plugins.length > 0) {
            await processAsyncArray(plugins, async (plugin: Plugin) => {
                const docs = await this.pluginDocs(plugin.path);

                const headers: MarkdownTableHeader[] = [
                    {
                        key: 'name',
                        title: 'Action'
                    },
                    {
                        key: 'description',
                        title: 'Description'
                    }
                ];

                const mapped = docs.methods.map(method => {
                    return {
                        name: method.name,
                        description: [method.description, method.comment].join(' ')
                    }
                })


                const md = this.createMdBuilder({ hasAutoGeneratedComment: true })
                    .lineBreak()
                    .h1(plugin.name, true)
                    .h2(docs.name, true)
                    .h5(docs.description)
                    .lineBreak()
                    .h2('Actions', true)
                    .table(headers, mapped);



                const content = md.build();

                let readmeContent = this.readText(plugin.path + '/README.md');

                const autoGeneratedContentIndex = readmeContent.indexOf(this.mdComment('Auto Generated Below'));
                if (autoGeneratedContentIndex > -1) {
                    readmeContent = readmeContent.substring(0, autoGeneratedContentIndex);
                }

                this.writeText(plugin.path + '/README.md', readmeContent + content);


            })
        }
    }

    private getLanesMarkdown(lanes: BillyMethodDocumentation[]) {
        if (lanes.length === 0) {
            return ''
        }
        const mapped = lanes.map((lane, index) => {
            return {
                index: index + 1,
                name: lane.name,
                description: lane.description
            }
        })
        const headers: MarkdownTableHeader[] = [
            {
                key: 'index',
                title: 'Index'
            },
            {
                key: 'name',
                title: 'Name'
            },
            {
                key: 'description',
                title: 'Description'
            },
        ];

        const content = this.createMdBuilder({ hasAutoGeneratedComment: true })
            .lineBreak()
            .h1('Lanes', true)
            .table(headers, mapped)
            .build();

        return content;
    }
}

// TYPES

export interface Plugin {
    name: string;
    path: string;
    docPath: string;
}

// UTIL

export async function processAsyncArray(array: any[], asyncFunc) {
    for (const el of array) {
        await asyncFunc(el);
    };
}



